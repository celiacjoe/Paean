#pragma kernel CSMain

Texture2D<float4> reader; 
RWTexture2D<float4> writer;
SamplerState _PointClamp;
float _time;
float _rx;
float _ry;
//float _mousex;
float _mousey;

float rd(float se) { return (frac(sin((se += 1.0)) * 43758.5453)); }
float3 rdv(float se) {
	float theta = rd(se) * (6.283);
	float z = rd(se) * 2.0 - 1.0;
	float a = sqrt(1.0 - z * z);
	float3 v = float3(a * cos(theta), a * sin(theta), z);
	return v * sqrt(rd(se));
}
float map(float value, float min1, float max1, float min2, float max2) {
	return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}
float3 mod(float3 x, float3 y)
{
	return x - y * floor(x / y);
}
float2x2 rot(float r) { float c = cos(r); float s = sin(r); return float2x2(c, s, -s, c); }
float box(float3 p, float3 s) {
	float3 d = abs(p) - s;
	return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
}
float bl(float2 p, float2 s) {
	float2 d = abs(p) - s;
	return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}
float2 opOR(in float2 a, in float2 b) {
	if (a.x < b.x) { return a; }
	return b;
}

float pat(float3 p) {
	float tt = clamp(map(_mousey , 0.9, 0.1, 0., 2.45), 0., 2.45);
	float3  pd = p;
	float3 p2 = p; float3 p3 = p; float3 p4 = p; float3 p5 = p;
	float3 re2 = float3(4.,4.,4.);
	p2 = mod(p2 + re2 * float3(0.5, 0.5, 0.), re2) - re2 * 0.5;
	p3 = mod(p3 + re2 * float3(0.5, 0., 0.5), re2) - re2 * 0.5;
	p4 = mod(p4 + re2 * float3(0., 0.5, 0.5), re2) - re2 * 0.5;
	p5 = mod(p5 + re2 * float3(0.,0.,0.), re2) - re2 * 0.5;
	float d5 = min(min(min(box(p2, float3(1.,1.,1.)), box(p3, float3(1., 1., 1.))),
		box(p4, float3(1., 1., 1.))), box(p5, float3(1., 1., 1.)));
	float d5i = max(-100., -d5);

	float3 pl = abs(p);
	if (pl.x > pl.z)pl.x = pl.z;
	if (pl.x > pl.y)pl.x = pl.y;

	float3 pl2 = abs(p);

	if (pl2.x > pl2.y)pl2.x = pl2.y;
	if (pl2.x < pl2.z)pl2.x = pl2.z;

	float3 pl3 = abs(p);

	if (pl3.x < pl3.y)pl3.x = pl3.y;
	float tl = 0.25;
	float d6 = clamp(length(frac(pl.x*1.5) - 0.5) - 0.2, -10., tl);
	float d7 = clamp(length(frac(pl2.x*1.5) - 0.5) - 0.2, -10., tl);
	float d8 = clamp(length(frac(pl3.x*1.5) - 0.5) - 0.2, -10., tl);
	float d7b = max(d7, d8);

	pd = abs(pd);
	pd -= float3(9.5,9.5,9.5);
	if (pd.x > pd.y)pd.xy = pd.yx;
	pd.x -= 2.;
	if (pd.x > pd.z)pd.xz = pd.zx;
	if (pd.z > pd.y)pd.zy = pd.yz;
	pd = 1.5 - abs(pd - 1.);

	float3 p9 = (p + 0.5) / 5.;
	float d9 = length(floor(p9) + smoothstep(0.5, 0.7, frac(p9))) - (0.5 + tt);
	float di = max(d6, d5);
	float di2 = max(d7b, d5i);
	float di3 = min(di, di2);

	float dt = max(di3, d9);
	return dt;
}
float2 map(float3 p) {
	float3 p1 = p;


	float f1 = pat(p1);
	float tb = 100.;
	float f3 = length(p1.xz) - tb;
	float f4 = min(max(-100., -f3), p.y + 20.);
	float b1 = dot(p, float3(0., -1., 0.)) + 20.;

	float2 art = float2(f1,0.);
	float2 m1 = float2(b1, 1.);
	float2 m2 = float2(f4, 0.);

	float2 a1 = opOR(m1, m2);
	float2 r0 = opOR(art, a1);
	return r0;
}
float3 norm(float3 p) {
	float2 e = float2(0, 0.01); return normalize(map(p).x
		- float3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));
}

float2 raymarch(in float3 ro, in float3 rd) {

	float t = 0.0;
	float2 float2Output = float2(50., 0.);
	for (int i = 0; i < 300; ++i) {
		float2 sce = map(ro + rd * t);
		if (sce.x < 0.01) {
			float2Output = float2(t, sce.y);
			break;
		}
		t += sce.x;
		// if (t > 40.){break;}
	}
	return float2Output;
}
float bz;
float raytrace(in float2 uv,float se) {
	float tt = clamp(map(_mousey , 0.9, 0.1, 0., 2.45), 0., 2.45);
	uv *= 2.;
	uv -= float2(1.9, -0.4);
	float3 ro = float3(uv, -10. - tt * 10.);
	float3 rd = normalize(float3(uv, 1.8));

	ro.xz = mul(ro.xz, rot(_time));
	rd.xz = mul(rd.xz, rot(_time));
	float color = 0.;
	float mco = 0.;
	float atten = 1.0;
	float bounces = 1.;
	float z1 = bl(uv, float2(1.,1.));
	for (int i = 0; i < 3; ++i)
	{
		if (z1 > 0.) { break; }
		float2 sce = raymarch(ro, rd);
		if (sce.y == 0.)
		{
			float3 p = ro + rd * sce.x;
			float3 n = norm(p);
			rd = n + rdv(se) * 1.5;
			ro = p + rd * 0.1;
			mco += atten;
			bounces += 1.0;
			atten *= 0.5;
		}
		else
		{
			color = lerp(1., mco , max(0.0, float(i)));
			break;
		}

	}
	color /= bounces;
	bz = z1;
	return color;
}

[numthreads(8,8,1)]
void CSMain (uint2 id : SV_DispatchThreadID) 
{
	float tt = clamp(map(_mousey, 0.65, 0.15, 0., 2.45), 0., 2.45);
	float2 f = float2(id.x,id.y);
	float2 res=float2(_rx,_ry); 
	float2 uc = f / res;
	float2 uv =( uc)*2.-1.;
	float tmp = 0.;
	float se = (res.y*uc.x + uc.y);
	se += _time;
	uv.x *= res.x / res.y;
	float color = raytrace(uv,se);
	float prevColor = reader.SampleLevel(_PointClamp, uc + 0.5 / res, 0).a;
	float result2 = max(color, prevColor*0.016);
	float r2 = step(0.001, result2);
	float t2 = lerp(lerp(r2, 0., step(0., bz)), 1., step(0.005 , bz));
	float2 us = uv + float2(0.45, 0.2);
	float bs = bl(us, float2(0.5, 0.5));
	float t1 = max( step(0.,bs),
		step(0., pat(float3(us*(10. + tt * 10.), sin(_time*0.5)*(2.6 + tt * 4.5)))));
	t1 *= max(step(bs, 0.), step(0.0025 , bs));
	float bm = clamp((se - 0.5)*2., -0.6, 0.8);
	float f8 = step(0., bl(uv + float2(1.45, 0.2), float2(0.001 , 0.5)))*step(0.0, bl(uv + float2(1.45, -0.3), float2(0.01, 0.001)))*step(0.0, bl(uv + float2(1.45, 0.7), float2(0.01, 0.001)));
	float f9 = lerp(1. - f8, f8, smoothstep(0.015, 0.018, distance(uv, float2(-1.45, clamp((_mousey- 0.5)*2., -0.7, 0.3)))));
	//float4 d2 = reader.SampleLevel(_LinearClamp, uv + 0.5 / res, 0);
	writer[id]=float4(t2*t1*float3(1., 1., 1.)*f9, result2);

}
